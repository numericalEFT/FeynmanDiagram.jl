var documenterSearchIndex = {"docs":
[{"location":"lib/GV/#GV-expansion-to-a-computational-graph","page":"GV expansion to a computational graph","title":"GV expansion to a computational graph","text":"","category":"section"},{"location":"lib/GV/#API","page":"GV expansion to a computational graph","title":"API","text":"","category":"section"},{"location":"lib/GV/","page":"GV expansion to a computational graph","title":"GV expansion to a computational graph","text":"Modules = [FeynmanDiagram.GV]","category":"page"},{"location":"lib/GV/#FeynmanDiagram.GV.diagdictGV","page":"GV expansion to a computational graph","title":"FeynmanDiagram.GV.diagdictGV","text":"function diagdictGV(type::Symbol, MaxOrder::Int, has_counterterm::Bool=false, dim::Int=3)\n\nGenerates a Graph Dict: the `dim`-dimensional spin/charge polarization or self-energy diagrams with static interactions in a given `type`, to a given maximum order `MaxOrder`, with switchable couterterms. \nGenerates fermionic/bosonic `LabelProduct`: `fermi_labelProd`/`bose_labelProd` for these Graphs.\nGenerates a Tuple (propagatorMap, interactionMap) for mapping `g.id` to the index of unique proapgators and interactions, respectively.\n\nArguments:\n\ntype (Symbol): The type of the Feynman diagrams, including :spinPolar, :chargePolar, :sigma, :green, or :freeEnergy.\ngkeys (Vector{Tuple{Int,Int,Int}}): The (order, Gorder, Vorder) of the diagrams. Gorder is the order of self-energy counterterms, and Vorder is the order of interaction counterterms. \ndim (Int): The dimension of the system (defaults to 3).\nspinPolarPara (Float64, optional): The spin-polarization parameter (nup - ndown) / (nup + ndown) (defaults to 0.0).\n\nReturns\n\nA tuple (diagrams, fermi_labelProd, bose_labelProd) where \n\ndiagrams is a Dict{Tuple{Int,Int,Int},Tuple{Vector{Graph},Vector{Vector{Int}}}} object representing the diagrams.   The key is (order, Gorder, Vorder). The element is a Tuple (diagrams, extT_labels).\nfermi_labelProd is a LabelProduct object containing the labels for the fermionic G objects in the diagrams, \nbose_labelProd is a LabelProduct object containing the labels for the bosonic W objects in the diagrams.\n(propagatorMap, interactionMap) maps g.id to the index of unique proapgators and interactions, respectively. \n\n\n\n\n\n","category":"function"},{"location":"lib/GV/#FeynmanDiagram.GV.diagdictGV-2","page":"GV expansion to a computational graph","title":"FeynmanDiagram.GV.diagdictGV","text":"function diagdictGV(type::Symbol, MaxOrder::Int, has_counterterm::Bool=false, dim::Int=3)\n\nGenerates a Graph Dict: the `dim`-dimensional spin/charge polarization or self-energy diagrams with static interactions in a given `type`, to a given maximum order `MaxOrder`, with switchable couterterms. \nGenerates fermionic/bosonic `LabelProduct`: `fermi_labelProd`/`bose_labelProd` for these Graphs.\nGenerates a Tuple (propagatorMap, interactionMap) for mapping `g.id` to the index of unique proapgators and interactions, respectively.\n\nArguments:\n\ntype (Symbol): The type of the Feynman diagrams, including :spinPolar, :chargePolar, :sigma, :green, or :freeEnergy.\nMaxorder (Int): The maximum actual order of the diagrams.\nhas_counterterm (Bool): false for G0W0, true for GW with self-energy and interaction counterterms (defaults to false).\ndim (Int): The dimension of the system (defaults to 3).\nspinPolarPara (Float64, optional): The spin-polarization parameter (nup - ndown) / (nup + ndown) (defaults to 0.0).\n\nReturns\n\nA tuple (diagrams, fermi_labelProd, bose_labelProd) where \n\ndiagrams is a Dict{Tuple{Int,Int,Int},Tuple{Vector{Graph},Vector{Vector{Int}}}} object representing the diagrams.   The key is (order, Gorder, Vorder). The element is a Tuple (diagrams, extT_labels).\nfermi_labelProd is a LabelProduct object containing the labels for the fermionic G objects in the diagrams, \nbose_labelProd is a LabelProduct object containing the labels for the bosonic W objects in the diagrams.\n(propagatorMap, interactionMap) maps g.id to the index of unique proapgators and interactions, respectively. \n\n\n\n\n\n","category":"function"},{"location":"lib/GV/#FeynmanDiagram.GV.eachorder_diag","page":"GV expansion to a computational graph","title":"FeynmanDiagram.GV.eachorder_diag","text":"function eachorder_diag(type::Symbol, order::Int, VerOrder::Int=0, GOrder::Int=0; loopPool::Union{LoopPool,Nothing}=nothing,\n    tau_labels::Union{Nothing,Vector{Int}}=nothing, GTypes::Union{Nothing,Vector{Int}}=nothing, VTypes::Union{Nothing,Vector{Int}}=nothing)\n\nGenerates a `Vector{Graph}`: the polarization diagrams with static interactions of a given order, where the actual order of diagrams equals to `order + VerOrder + 2 * GOrder`.\nGenerates fermionic/bosonic `LabelProduct`: `fermi_labelProd`/`bose_labelProd` with inputs `tau_labels`, `GTypes`/`VTypes`, and updated `loopPool`. \nGenerates external tau labels Vector{Vector{Int}}. The i-th labels (Vector{Int}) corresponds to the i-th `Graph` in `Vector{Graph}`.\n\nArguments:\n\ntype (Symbol): The type of the diagrams, including :spinPolar, :chargePolar, :sigma, :green, or :freeEnergy.\norder (Int): The order of the diagrams without counterterms.\nVerOrder (Int, optional): The order of interaction counterterms (defaults to 0).\nGOrder (Int, optional): The order of self-energy counterterms (defaults to 0).\ndim (Int, optional): The dimension of the system (defaults to 3).\nspinPolarPara (Float64, optional): The spin-polarization parameter (nup - ndown) / (nup + ndown) (defaults to 0.0).\nloopPool (Union{LoopPool,Nothing}=nothing, optional): The initial pool of loop momenta (defaults to nothing).\ntau_labels(Union{Nothing, Vector{Int}}, optional): The labels for the discrete time of each vertex. (defaults to nothing).\nGTypes: The types of fermion propagators G in the diagrams (defaults to collect(0:GOrder)).\nVTypes: The types of boson static interaction V in the diagrams (defaults to collect(0:VerOrder)).\n\nReturns\n\nA tuple (diagrams, fermi_labelProd, bose_labelProd, extT_labels) where \n\ndiagrams is a Vector{Graph} object representing the diagrams, \nfermi_labelProd is a LabelProduct object containing the labels for the fermionic G objects in the diagrams, \nbose_labelProd is a LabelProduct object containing the labels for the bosonic W objects in the diagrams.\nextT_labels is a Vector{Vector{Int}} object containing the external tau labels for each Graph in diagrams.\n\n\n\n\n\n","category":"function"},{"location":"lib/GV/#FeynmanDiagram.GV.leafstates-Union{Tuple{G}, Tuple{T}, Tuple{Dict{T, Tuple{Vector{G}, Vector{Vector{Int64}}}}, LabelProduct, LabelProduct, Vector{T}}} where {T, G<:Graph}","page":"GV expansion to a computational graph","title":"FeynmanDiagram.GV.leafstates","text":"function leafstates(\n    FeynGraphs::Dict{T, Tuple{Vector{G}, Vector{Vector{Int}}}},\n    FermiLabel::LabelProduct, BoseLabel::LabelProduct,\n    graph_keys::Vector{T}\n) where {T, G <: Graph}\n\nExtracts leaf information from a Dict collection of Feynman graphs (`FeynGraphs` with its keys `graph_keys`)\nand their associated LabelProduct data (`FermiLabel` and `BoseLabel`). \nThe information includes their initial value, type, in/out time, and loop momenta.\n\nArguments:\n\nFeynGraphs: A dictionary mapping keys of type T to tuples containing a vector of Graph objects and a vector of external time labels.\nFermiLabel: A LabelProduct used to label the fermionic G objects in the graphs.\nBoseLabel: A LabelProduct used to label bosonic W objects in the graphs.\ngraph_keys: A vector containing keys of type T, specifying which graphs to analyze.\n\nReturns\n\nA tuple of vectors containing information about the propagators in the graphs, including their initial values, types, input and output time indexes, and loop-momenta indexes.\nA tuple of vectors containing information about the interactions in the graphs, including their initial values, types, input and output time indexes, and loop-momenta indexes.\nA Vector{Vector{Int}} representing the external tau variables of each vector of graph corresponding to each key of type T.\n\n\n\n\n\n","category":"method"},{"location":"lib/GV/#FeynmanDiagram.GV.read_diagrams-Tuple{AbstractString}","page":"GV expansion to a computational graph","title":"FeynmanDiagram.GV.read_diagrams","text":"function read_diagrams(filename::AbstractString; loopPool::Union{LoopPool,Nothing}=nothing,\n    dim::Int=3, tau_labels::Union{Nothing,Vector{Int}}=nothing, GTypes=[0, 1], VTypes=[0, 1, 2],\n    keywords::Vector{String}=[\"Polarization\", \"DiagNum\", \"Order\", \"GNum\", \"Ver4Num\", \"LoopNum\", \"ExtLoopIndex\",\n        \"DummyLoopIndex\", \"TauNum\", \"ExtTauIndex\", \"DummyTauIndex\"])\n\nReads a GV_diagrams file and returns Graph of diagrams in this file \nand the corresponding `LabelProduct` objects, which are used to keep track of QuantumOperator.label.\n\nArguments:\n\nfilename (AbstractString): The path to the file containing the diagrams.\nloopPool (Union{LoopPool,Nothing}): An optional LoopPool object. If not provided, a new one will be created.\nspinPolarPara (Float64): The spin-polarization parameter (nup - ndown) / (nup + ndown) (defaults to 0.0).\ndim (Int): The dimension of the system, used to initialize the LoopPool object. Default is 3.\ntau_labels (Union{Nothing,Vector{Int}}): The labels for the Tau objects in the diagrams. If not provided, they will be set to the integers from 1 to tauNum.\nGTypes (Vector{Int}): The labels for the fermionic G objects in the diagrams. Default is [0, 1].\nVTypes (Vector{Int}): The labels for the bosonic V objects in the diagrams. Default is [0, 1, 2].\nkeywords (Vector{String}): A set of keywords used to extract information from the file. Default is [\"Polarization\", \"DiagNum\", \"Order\", \"GNum\", \"Ver4Num\", \"LoopNum\", \"ExtLoopIndex\", \"DummyLoopIndex\", \"TauNum\", \"ExtTauIndex\", \"DummyTauIndex\"].\n\nReturns\n\nA tuple (diagrams, fermi_labelProd, bose_labelProd) where \n\ndiagrams is a Graph object representing the diagrams, \nfermi_labelProd is a LabelProduct object containing the labels for the fermionic G objects in the diagrams, \nbose_labelProd is a LabelProduct object containing the labels for the bosonic W objects in the diagrams.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#Quantum-operator-and-its-product","page":"Quantum operator and its product","title":"Quantum operator and its product","text":"","category":"section"},{"location":"lib/operator/#API","page":"Quantum operator and its product","title":"API","text":"","category":"section"},{"location":"lib/operator/","page":"Quantum operator and its product","title":"Quantum operator and its product","text":"Modules = [FeynmanDiagram.QuantumOperators]","category":"page"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.OperatorProduct","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.OperatorProduct","text":"struct OperatorProduct <: AbstractVector{QuantumOperator}\n\nstruct of a quantum-operator product. It is a subtype of `AbstractVector` and\ninherits a large set of Vector behaviors including iteration and indexing.\n\nMembers:\n\noperators::Vector{QuantumOperator}  vector of quantum operators\n\n\n\n\n\n","category":"type"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.QuantumOperator","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.QuantumOperator","text":"struct QuantumOperator\n\nstruct of a quantum operator.\n\nMembers:\n\noperator::Datatype: type of quantum operator, supports :f‚Å∫, :f‚Åª, :f, :b‚Å∫, :b‚Åª, :œï\nlabel::Int:  label of the operator indices. It could represent spacetime, spin, momentum, flavor, etc.\nis_ghost::Bool: whether the operator is a ghost operator or not.\n\n\n\n\n\n","category":"type"},{"location":"lib/operator/#Base.:*-Tuple{QuantumOperator, QuantumOperator}","page":"Quantum operator and its product","title":"Base.:*","text":"Base.:*(o1::Union{QuantumOperator, OperatorProduct}, o2::Union{QuantumOperator, OperatorProduct})\n\n`o1 * o2` returns the quantum operator product of `o1` and `o2`\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#Base.adjoint-Tuple{OperatorProduct}","page":"Quantum operator and its product","title":"Base.adjoint","text":"Base.adjoint(o::OperatorProduct)\n\nReturn the conjuated composite operator of `o`.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#Base.adjoint-Tuple{QuantumOperator}","page":"Quantum operator and its product","title":"Base.adjoint","text":"Base.adjoint(operator::QuantumOperator)\n\nReturn the conjuated quantum operator of `operator`.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.correlator_order-Tuple{OperatorProduct}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.correlator_order","text":"function correlator_order(operator::OperatorProduct)\nfunction correlator_order(operator::OperatorProduct)\n\nConvert a OperatorProduct to correlator-ordered form. \nReturns the associated statistical sign and permutation.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.fermionic_annihilation-Tuple{Any}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.fermionic_annihilation","text":"Create a OperatorProduct with one quantum operator from given label `i`.\nIt supports the following abbreviated function form:\n\n''' const ùëì‚Åª = fermionicannihilation const ùëì‚Å∫ = fermioniccreation const ùëì = majorana const ùëè‚Åª = bosonicannihilation const ùëè‚Å∫ = bosoniccreation const ùúô = real_classic '''\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.isannihilation-Tuple{QuantumOperator}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.isannihilation","text":"function isannihilation(operator::QuantumOperator)\n\nCheck if `operator` is an annihilation operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.iscreation-Tuple{QuantumOperator}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.iscreation","text":"function iscreation(operator::QuantumOperator)\n\nCheck if `operator` is a creation operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.isfermionic-Tuple{OperatorProduct}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.isfermionic","text":"function isfermionic(o::OperatorProduct)\n\nCheck if `o` is a fermionic composite operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.isfermionic-Tuple{QuantumOperator}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.isfermionic","text":"function isfermionic(operator::QuantumOperator)\n\nCheck if `operator` is a fermionic operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.normal_order-Tuple{OperatorProduct}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.normal_order","text":"function normal_order(operator::OperatorProduct)\n\nComputes the permutation required to convert a OperatorProduct to normal-ordered form. \nReturns the associated statistical sign and permutation.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.parity-Tuple{W} where W<:AbstractVector{Int64}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.parity","text":"The parity of a permutation P is +1 if the number of 2-cycles (swaps) in an n-cycle decomposition with n ‚â§ 2 is even, and -1 if the number of 2-cycles is odd.\n\n\n\n\n\n","category":"method"},{"location":"lib/operator/#FeynmanDiagram.QuantumOperators.parity_old-Tuple{Any}","page":"Quantum operator and its product","title":"FeynmanDiagram.QuantumOperators.parity_old","text":"calculate the parity of a given permutation of the array [1, 2, 3, ...]\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#Diagrams-as-an-Expression-Tree","page":"Diagrams as an Expression Tree","title":"Diagrams as an Expression Tree","text":"","category":"section"},{"location":"lib/exprtree/#API","page":"Diagrams as an Expression Tree","title":"API","text":"","category":"section"},{"location":"lib/exprtree/","page":"Diagrams as an Expression Tree","title":"Diagrams as an Expression Tree","text":"Modules = [FeynmanDiagram.ExprTree]","category":"page"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.LoopPool","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.LoopPool","text":"struct LoopPool{T}\n\nPool of loop basis. Each loop basis corresponds to a loop variable.\nA loop variable is a linear combination of N independent loops. The combination coefficients is what we call a loop basis.\nFor example, if a loop is a momentum K, then\n\nvaribale_i = K_1*basis[1, i] + K_2*basis[2, i] + K_3*basis[3, i] + ...\n\nMembers\n\nname::Symbol : name of the pool\ndim::Int     : dimension of a loop variable (for example, the dimension of a momentum-frequency loop variable is (d+1) where d is the spatial dimension)\nN::Int       : number of independent loops (dimension of loop basis)\nbasis::Matrix{T}    : Matrix of (N x Nb) that stores the loop basis, where Nb is the number of loop basis (or number of loop variables).\ncurrent::Matrix{T}  : Matrix of (dim x Nb) that stores the loop variables, where Nb is the number of loop basis (or number of loop variables).\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.Node","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.Node","text":"mutable struct Node{PARA,F}\n\nNode Object, which is the building block of the diagram tree. Each node is a collection of CACHED proapgator objects and other child CACHED node objects\n\nMembers\n\npara::PARA     : user-defined parameters, which will be used to evaluate the factor and the weight of the node (e.g., if the node represents a vertex function, then the parameter may be the momentum basis of the external legs)\noperation::Int : #1: multiply, 2: add, ...\nfactor::F      : additional factor of the node\ncomponents::Vector{Vector{Int}}  : Index to the cached propagators stored in certain pools. Each Vector{Int} is for one kind of propagator.\nchildNodes::Vector{Int}  : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree.\nparent::Int : Index to the cached nodes which is the parent of the current node.\n\n\n\n\n\n","category":"type"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.addnode!-Union{Tuple{W}, Tuple{F}, Tuple{PARA}, Tuple{V}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any, Union{Tuple, AbstractVector}}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any, Union{Tuple, AbstractVector}, Any}} where {V, PARA, F, W}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.addnode!","text":"function addnode!(diag::ExpressionTree{V,PARA,F,W}, operator, name, children::Union{Tuple, AbstractVector}, factor = 1.0; para = nothing) where {V,PARA,F,W}\n\nAdd a node into the expression tree.\n\nArguments\n\ndiag::ExpressionTree  : diagrammatic experssion tree.\noperator::Int         : #1: multiply, 2: add, ...\nname                  : name of the node\nchildren              : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree. It should be in the format of Vector{Int}.\nfactor = 1.0          : Factor of the node\npara = nothing        : Additional paramenter required to evaluate the node. Set to nothing by default.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.addpropagator!-Union{Tuple{W}, Tuple{F}, Tuple{PARA}, Tuple{V}, Tuple{ExpressionTree{V, PARA, F, W}, Any}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any}} where {V, PARA, F, W}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.addpropagator!","text":"function addPropagator!(diag::ExpressionTree, name, factor = 1.0; site = [], loop = nothing, para = nothing, order::Int = 0)\n\nAdd a propagator into the diagram tree.\n\nArguments\n\ndiag           : diagrammatic experssion tree.\norder::Int = 0 : Order of the propagator.\nname = :none   : name of the propagator.\nfactor = 1     : Factor of the propagator.\nsite = []      : site basis (e.g, time and space coordinate) of the propagator.\nloop = nothing : loop basis (e.g, momentum and frequency) of the propagator.\npara = nothing : Additional paramenter required to evaluate the propagator.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.getNode-Tuple{Any, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.getNode","text":"function getNode(diag::Diagrams, nidx::Int)\n\nget Node in the diag with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.getNodeWeight-Tuple{Any, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.getNodeWeight","text":"function getNodeWeight(tree, nidx::Int)\n\nget Node weight in the diagram experssion tree with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/exprtree/#FeynmanDiagram.ExprTree.showTree-Tuple{ExpressionTree, Int64}","page":"Diagrams as an Expression Tree","title":"FeynmanDiagram.ExprTree.showTree","text":"showTree(diag::Diagrams, _root = diag.root[end]; verbose = 0, depth = 999)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag: the Diagrams struct to visualize\n_root: the index of the root node to visualize\nverbose=0: the amount of information to show\ndepth=999: deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#Diagrams-as-an-AbstractTree","page":"Diagrams as an AbstractTree","title":"Diagrams as an AbstractTree","text":"","category":"section"},{"location":"lib/diagtree/#API","page":"Diagrams as an AbstractTree","title":"API","text":"","category":"section"},{"location":"lib/diagtree/","page":"Diagrams as an AbstractTree","title":"Diagrams as an AbstractTree","text":"Modules = [FeynmanDiagram.DiagTree]","category":"page"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.BareGreenNId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.BareGreenNId","text":"time-ordered N-point Bare Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.BareHoppingId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.BareHoppingId","text":"hopping function c‚Å∫c‚Åª\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.ConnectedGreenNId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.ConnectedGreenNId","text":"time-ordered N-point Composite Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.Diagram","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.Diagram","text":"mutable struct Diagram{W}\n\nstruct of a diagram. A diagram of a sum or produce of various subdiagrams.\n\nMembers\n\nhash::Int          : the unique hash number to identify the diagram\nname::Symbol       : name of the diagram\nid::DiagramId      : diagram id \noperator::Operator : operation, support Sum() and Prod()\nfactor::W          : additional factor of the diagram\nsubdiagram::Vector{Diagram{W}}   : vector of sub-diagrams\nweight::W          : weight of the diagram\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.DiagramId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.DiagramId","text":"abstract type DiagramId end\n\nThe abstract type of all diagrams/subdiagrams/bare propagators\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.GreenNId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.GreenNId","text":"time-ordered N-point Composite Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.PropagatorId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.PropagatorId","text":"abstract type PropagatorId <: DiagramId end\n\nThe abstract type of all bare propagators\n\n\n\n\n\n","category":"type"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.derivative-Union{Tuple{ID}, Tuple{Union{Tuple, AbstractVector}, Type{ID}, Int64}} where ID<:PropagatorId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.derivative","text":"function derivative(diags::Union{Diagram,Tuple,AbstractVector}, ::Type{ID}, order::Int) where {ID<:PropagatorId}\n\nAutomatic differentiation derivative on the diagrams\n\nArguments\n\ndiags      : diagrams to take derivative\nID         : DiagramId to apply the differentiation\norder::Int : derivative order\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.derivative-Union{Tuple{ID}, Tuple{Union{Tuple, AbstractVector}, Type{ID}}} where ID<:PropagatorId","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.derivative","text":"function derivative(diags::Union{Tuple,AbstractVector}, ::Type{ID}; index::Int=index(ID)) where {W,ID<:PropagatorId}\nfunction derivative(diags::Vector{Diagram{W}}, ::Type{ID}; index::Int=index(ID)) where {W,ID<:PropagatorId}\n\nAutomatic differentiation derivative on the diagrams\n\nArguments\n\ndiags     : diagrams to take derivative\nID        : DiagramId to apply the differentiation\nindex     : index of the id.order array element to increase the order\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.plot_tree-Tuple{Diagram}","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.plot_tree","text":"function plot_tree(diag::Diagram; verbose = 0, maxdepth = 6)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag        : the Diagram struct to visualize\nverbose=0   : the amount of information to show\nmaxdepth=6  : deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.removeDuplicatedLeaves!-Union{Tuple{Array{Diagram{W}, 1}}, Tuple{W}} where W","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.removeDuplicatedLeaves!","text":"removeDuplicatedLeaves!(diags::AbstractVector; verbose = 0)\n\nremove duplicated nodes such as:  ---> ver4 ---> InteractionId. Leaf will not be touched!\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.removeHartreeFock!-Union{Tuple{Diagram{W}}, Tuple{W}} where W","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.removeHartreeFock!","text":"function removeHartreeFock!(diag::Diagram{W}) where {W}\nfunction removeHartreeFock!(diags::Union{Tuple,AbstractVector})\n\nRemove the Hartree-Fock insertions that without any derivatives on the propagator and the interaction.\n\nArguments\n\ndiags      : diagrams to remove the Fock insertion\n\nRemarks\n\nThe operations removeHartreeFock! and taking derivatives doesn't commute with each other! \nIf the input diagram is a Hartree-Fock diagram, then the overall weight will become zero! \nThe return value is always nothing\n\n\n\n\n\n","category":"method"},{"location":"lib/diagtree/#FeynmanDiagram.DiagTree.removeOneChildParent!-Union{Tuple{Array{Diagram{W}, 1}}, Tuple{W}} where W","page":"Diagrams as an AbstractTree","title":"FeynmanDiagram.DiagTree.removeOneChildParent!","text":"removeOneChildParent!(diags::AbstractVector; verbose = 0)\n\nremove duplicated nodes such as:  ---> ver4 ---> InteractionId. Leaf will not be touched!\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#Front-end-translates-a-source-code-into-a-computational-graph","page":"Front-end translates a source code into a computational graph","title":"Front-end translates a source code into a computational graph","text":"","category":"section"},{"location":"lib/frontend/#API","page":"Front-end translates a source code into a computational graph","title":"API","text":"","category":"section"},{"location":"lib/frontend/","page":"Front-end translates a source code into a computational graph","title":"Front-end translates a source code into a computational graph","text":"Modules = [FeynmanDiagram.FrontEnds]","category":"page"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.LabelProduct","page":"Front-end translates a source code into a computational graph","title":"FeynmanDiagram.FrontEnds.LabelProduct","text":"The cartesian QuantumOperator.label product:\n\n#Parameters:\n\n'LT': Type of labels\n'N' : Number of labels' type\n\n#Members:\n\n'labels' : The list of labels in the LabelProduct\n'dims' : A tuple of the length of the label factors\n\n\n\n\n\n","category":"type"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.LoopPool","page":"Front-end translates a source code into a computational graph","title":"FeynmanDiagram.FrontEnds.LoopPool","text":"struct LoopPool{T}\n\nPool of loop basis. Each loop basis corresponds to a loop variable.\nA loop variable is a linear combination of N independent loops. The combination coefficients is what we call a loop basis.\nFor example, if a loop is a momentum K, then\n\nvaribale_i = K_1*basis[1, i] + K_2*basis[2, i] + K_3*basis[3, i] + ...\n\nMembers\n\nname::Symbol : name of the pool\ndim::Int     : dimension of a loop variable (for example, the dimension of a momentum-frequency loop variable is (d+1) where d is the spatial dimension)\nbasis::Matrix{T}    : Matrix of (N x Nb) that stores the loop basis, where Nb is the number of loop basis (or number of loop variables).\nloops::Matrix{T}  : Matrix of (dim x Nb) that stores the loop variables, where Nb is the number of loop basis (or number of loop variables).\n\n\n\n\n\n","category":"type"},{"location":"lib/frontend/#Base.length-Tuple{LabelProduct}","page":"Front-end translates a source code into a computational graph","title":"Base.length","text":"function Base.length(obj::LabelProduct)\n\nReturn the number of grids of the LabelProduct.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#Base.show-Tuple{IO, LabelProduct}","page":"Front-end translates a source code into a computational graph","title":"Base.show","text":"function Base.show(io::IO, obj::LabelProduct)\n\nPrint the LabelProduct.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#Base.size-Tuple{LabelProduct, Int64}","page":"Front-end translates a source code into a computational graph","title":"Base.size","text":"function Base.size(obj::LabelProduct, I::Int)\n\nReturn the length of the specifict Ith label factor of the LabelProduct.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#Base.size-Tuple{LabelProduct}","page":"Front-end translates a source code into a computational graph","title":"Base.size","text":"function Base.size(obj::LabelProduct, I::Int)\n\nReturn the length of the specifict Ith label factor of the LabelProduct.\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.index_to_linear-Union{Tuple{N}, Tuple{LT}, Tuple{LabelProduct{LT, N}, Vararg{Any}}} where {LT, N}","page":"Front-end translates a source code into a computational graph","title":"FeynmanDiagram.FrontEnds.index_to_linear","text":"function index_to_linear(obj::LabelProduct, index...)\n\nConvert a tuple of the indexes of each label to a single linear index of the LabelProduct.\n\nArgument:\n\n'obj': The LabelProduct object\n'index...': N indexes of the label factor, where N is the number of label factor\n\n\n\n\n\n","category":"method"},{"location":"lib/frontend/#FeynmanDiagram.FrontEnds.linear_to_index-Union{Tuple{N}, Tuple{LT}, Tuple{LabelProduct{LT, N}, Int64}} where {LT, N}","page":"Front-end translates a source code into a computational graph","title":"FeynmanDiagram.FrontEnds.linear_to_index","text":"function linear_to_index(obj::LabelProduct, I::Int)\n\nConvert the single linear index of the LabelProduct to a tuple of indexes of each label. \n\nArgument:\n\n'obj': The LabelProduct object\n'I': The linear index of the LabelProduct \n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#Parquet-Algorithm-to-Build-Diagrams","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"","category":"section"},{"location":"lib/parquet/#API","page":"Parquet Algorithm to Build Diagrams","title":"API","text":"","category":"section"},{"location":"lib/parquet/","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"Modules = [FeynmanDiagram.Parquet]","category":"page"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.ParquetBlocks","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.ParquetBlocks","text":"struct ParquetBlocks\n\nThe channels of the left and right sub-vertex4 of a bubble diagram in the parquet equation\n\n#Members\n\nphi   : channels of left sub-vertex for the particle-hole and particle-hole-exchange bubbles\nppi   : channels of left sub-vertex for the particle-particle bubble\nŒì4   : channels of right sub-vertex of all channels\n\n\n\n\n\n","category":"type"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.ep_coupling-Union{Tuple{DiagPara{W}}, Tuple{W}} where W","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.ep_coupling","text":"function ep_coupling(para::DiagPara{W};\n    extK=[DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2), DiagTree.getK(para.totalLoopNum, 3)],\n    channels::AbstractVector=[PHr, PHEr, PPr, Alli],\n    subdiagram=false,\n    name=:none, resetuid=false,\n    blocks::ParquetBlocks=ParquetBlocks()\n) where {W}\n\nGenerate electron-phonon 4-vertex diagrams using Parquet Algorithm. The right incoming Tau will be set to the last Tau for all diagrams |         | Œì3 ‚Äì‚Äì‚Äì-| |         |\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [left in, left out, right in, right out]. \nchannels        : vector of channels in the left Œì3 diagrams. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :extT, :diagram, :hash. \n\nOutput\n\nA DataFrame with fields :response, :type, :extT, :diagram, :hash\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.green-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, Any}, Tuple{DiagPara{W}, Any, Any, Any}} where W","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.green","text":"green(para::DiagPara, extK = DiagTree.getK(para.totalLoopNum, 1), extT = para.hasTau ? (1, 2) : (0, 0), subdiagram = false;\n    name = :G, resetuid = false, blocks::ParquetBlocks=ParquetBlocks())\n\nBuild composite Green's function. By definition, para.firstTauIdx is the first Tau index of the left most self-energy subdiagram.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nextT: [Tau index of the left leg, Tau index of the right leg]\nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA Diagram object or nothing if the Green's function is illegal. \n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.polarization-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, Any}} where W","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.polarization","text":"function polarization(para, extK = DiagTree.getK(para.totalLoopNum, 1), subdiagram = false; name = :Œ†, resetuid = false, blocks::ParquetBlocks=ParquetBlocks())\n\nGenerate polarization diagrams using Parquet Algorithm.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :diagram, :hash. \nAll polarization share the same external Tau index. With imaginary-time variables, they are extT = (para.firstTauIdx, para.firstTauIdx+1)\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.sigma-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, Any}} where W","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.sigma","text":"function sigma(para, extK = DiagTree.getK(para.totalLoopNum, 1), subdiagram = false; name = :Œ£, resetuid = false, blocks::ParquetBlocks=ParquetBlocks())\n\nBuild sigma diagram.  When sigma is created as a subdiagram, then no Fock diagram is generated if para.filter contains NoFock, and no sigma diagram is generated if para.filter contains Girreducible\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :type, :extT, :diagram, :hash\nAll sigma share the same incoming Tau index, but not the outgoing one\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.vertex3-Union{Tuple{DiagPara{WW}}, Tuple{WW}, Tuple{DiagPara{WW}, Any}, Tuple{DiagPara{WW}, Any, Any}} where WW","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.vertex3","text":"function vertex3(para, extK = [DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2)],\n    subdiagram = false; name = :Œì3, chan = [PHr, PHEr, PPr, Alli], resetuid = false, \n    blocks::ParquetBlocks=ParquetBlocks()\n    )\n\nGenerate 3-vertex diagrams using Parquet Algorithm. With imaginary-time variables, all vertex3 generated has the same bosonic Tidx extT1=parafirstTauIdx and the incoming fermionic Tidx extT2=parafirstTauIdx+1.\n\n#Arguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [bosonic leg (out), fermionic in, fermionic out], extK[1] = extK[2] - extK[3]. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nchan            : vector of channels of the current 4-vertex. \nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :extT, :diagram, :hash. \n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#FeynmanDiagram.Parquet.vertex4-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, AbstractVector}, Tuple{DiagPara{W}, Any, AbstractVector, Any}} where W","page":"Parquet Algorithm to Build Diagrams","title":"FeynmanDiagram.Parquet.vertex4","text":"vertex4(para::DiagPara,\n    extK = [DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2), DiagTree.getK(para.totalLoopNum, 3)],\n    chan::AbstractVector = [PHr, PHEr, PPr, Alli],\n    subdiagram = false;\n    level = 1, name = :none, resetuid = false,\n    blocks::ParquetBlocks=ParquetBlocks(),\n    blockstoplevel::ParquetBlocks=blocks\n    )\n\nGenerate 4-vertex diagrams using Parquet Algorithm\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [left in, left out, right in, right out]. \nchan            : vector of channels of the current 4-vertex. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nlevel           : level in the diagram tree\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\nblockstoplevel  : building blocks of the Parquet equation at the toplevel. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :type, :extT, :diagram, :hash\n\n\n\n\n\n","category":"method"},{"location":"lib/parquet/#Usage","page":"Parquet Algorithm to Build Diagrams","title":"Usage","text":"","category":"section"},{"location":"lib/parquet/","page":"Parquet Algorithm to Build Diagrams","title":"Parquet Algorithm to Build Diagrams","text":"using FeynmanDiagram\npara = DiagPara(type = Ver4Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex4(para)\n\npara = DiagPara(type = Ver3Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex3(para)\n\npara = DiagPara(type = SigmaDiag, innerLoopNum = 1, hasTau = true);\nParquet.sigma(para)\n\npara = DiagPara(type = PolarDiag, innerLoopNum = 1, hasTau = true);\nParquet.polarization(para)","category":"page"},{"location":"lib/computgraph/#Computational-graph-for-general-feynman-diagrams","page":"Computational graph for general feynman diagrams","title":"Computational graph for general feynman diagrams","text":"","category":"section"},{"location":"lib/computgraph/#API","page":"Computational graph for general feynman diagrams","title":"API","text":"","category":"section"},{"location":"lib/computgraph/","page":"Computational graph for general feynman diagrams","title":"Computational graph for general feynman diagrams","text":"Modules = [FeynmanDiagram.ComputationalGraphs]","category":"page"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.Graph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.Graph","text":"mutable struct Graph{F,W}\n\nComputational Graph representation of a collection of Feynman diagrams. All Feynman diagrams should share the same set of external and internal vertices.\n\nMembers:\n\nid::Int  the unique hash id to identify the diagram\nname::Symbol  name of the diagram\ntype::DataType  type of the diagram, support Interaction, ExternalVertex, Propagator, SelfEnergy, VertexDiag, GreenDiag, and GenericDiag.\norders::Vector{Int}  orders of the diagram, e.g. loop order, derivative order, etc.\nvertices::Vector{OperatorProduct}  vertices of the diagram. Each index is composited by the product of quantum operators. \ntopology::Vector{Vector{Int}} topology of the diagram. Each Vector{Int} stores vertices' index connected with each other (as a propagator). \nexternal::Vector{Int}  index of ACTUAL external vertices (as QuantumOperators)\nhasLeg::Vector{Bool} index of each external operator (true: legged, false: nonleg)\nsubgraphs::Vector{Graph{F,W}}  vector of sub-diagrams \nsubgraph_factors::Vector{F}  scalar multiplicative factors associated with each subdiagram\noperator::DataType  node operation, support Sum and Prod\nfactor::F  total scalar multiplicative factor for the diagram\nweight::W  weight of the diagram\n\nExample:\n\njulia> g1 = Graph([], vertices=[ùëì‚Å∫(1),ùëì‚Åª(2)], external=[1,2], hasLeg=[true,true])\n1:f‚Å∫(1)|f‚Åª(2)=0.0\n\njulia> g2 = Graph([], vertices=[ùëì‚Å∫(3),ùëì‚Åª(4)], external=[1,2], hasLeg=[true,true])\n2:f‚Å∫(3)|f‚Åª(4)=0.0\n\njulia> g = Graph([g1,g2], vertices=[ùëì‚Å∫(1),ùëì‚Åª(2),ùëì‚Å∫(3),ùëì‚Åª(4)], operator=ComputationalGraphs.Prod(), external=[1,2,3,4], hasLeg=[true,true,true,true])\n3:f‚Å∫(1)|f‚Åª(2)|f‚Å∫(3)|f‚Åª(4)=0.0=‚ìç (1,2)\n\n\n\n\n\n","category":"type"},{"location":"lib/computgraph/#Base.show-Tuple{IO, Graph}","page":"Computational graph for general feynman diagrams","title":"Base.show","text":"show(io::IO, g::Graph)\n\nWrite a text representation of `Graph` to the output stream `io`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.alleq-Tuple{Any}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.alleq","text":"Checks that all elements of an iterable x are equal.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.collect_labels-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.collect_labels","text":"function collect_labels(g::Graph)\n\nReturns the list of sorted unique labels in graph g.\n\nArguments:\n\ng::Graph: graph to find labels for\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.eldest-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.eldest","text":"function eldest(g::Graph)\n\nReturns the first child (subgraph) of a graph g.\n\nArguments:\n\ng::Graph: graph for which to find the first child\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.external-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.external","text":"function external(g::Graph)\n\nReturn all physical external vertices (::OperatorProduct}) of Graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.external_labels-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.external_labels","text":"function external_labels(g::Graph)\n\nReturn the labels of all physical external vertices of Graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.external_vertex-Tuple{OperatorProduct}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.external_vertex","text":"function external_vertex(ops::OperatorProduct;\n    name=\"\", factor=one(_dtype.factor), weight=zero(_dtype.weight), operator=Sum())\nCreate a ExternalVertex-type Graph from given OperatorProduct `ops`, including several quantum operators for an purely external vertex.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.feynman_diagram-Union{Tuple{W}, Tuple{F}, Tuple{Array{Graph{F, W}, 1}, Vector{Vector{Int64}}}, Tuple{Array{Graph{F, W}, 1}, Vector{Vector{Int64}}, Union{Nothing, Vector{Int64}}}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.feynman_diagram","text":"function feynman_diagram(subgraphs::Vector{Graph{F,W}}, topology::Vector{Vector{Int}}, perm_noleg::Union{Vector{Int},Nothing}=nothing;\n    factor=one(_dtype.factor), weight=zero(_dtype.weight), name=\"\", diagtype::GraphType=GenericDiag()) where {F,W}\n\nCreate a Graph representing feynman diagram from all subgraphs and topology (connections between vertices),\nwhere each ExternalVertex is given in `vertices`, \nwhile internal vertices are constructed with external legs of graphs in `vertices`, or simply OperatorProduct in `vertices`.\n\nArguments:\n\nsubgraphs::Vector{Graph{F,W}} all subgraphs of the diagram. All external operators of subgraphs constitute all operators of the new diagram.\ntopology::Vector{Vector{Int}} topology of the diagram. Each Vector{Int} stores operators' index connected with each other (as a propagator). \nperm_noleg::Union{Vector{Int},Nothing}=nothing permutation of all the nonleg external operators. By default, setting nothing means to use the default order from subgraphs.\nfactor::F  overall scalar multiplicative factor for this diagram (e.g., permutation sign)\nweight  weight of the diagram\nname  name of the diagram\ntype  type of the diagram\n\nExample:\n\njulia> V = [ùëì‚Å∫(1)ùëì‚Åª(2)ùúô(3), ùëì‚Å∫(4)ùëì‚Åª(5)ùúô(6), ùëì‚Å∫(7)ùëì‚Åª(8)ùúô(9)];\njulia> g = feynman_diagram(interaction.(V), [[1, 5], [3, 9], [4, 8]], [3, 1, 2])\n7:f‚Å∫(1)f‚Åª(2)œï(3)|f‚Å∫(4)f‚Åª(5)œï(6)|f‚Å∫(7)f‚Åª(8)œï(9)=0.0=‚ìç (1,2,3,4,5,6)\n\njulia> g.subgraphs\n6-element Vector{Graph{Float64, Float64}}:\n 1:f‚Å∫(1)f‚Åª(2)œï(3)=0.0\n 2:f‚Å∫(4)f‚Åª(5)œï(6)=0.0\n 3:f‚Å∫(7)f‚Åª(8)œï(9)=0.0\n 4:f‚Å∫(1)|f‚Åª(5)‚ãÖ-1.0=0.0\n 5:œï(3)|œï(9)=0.0\n 6:f‚Å∫(4)|f‚Åª(8)‚ãÖ-1.0=0.0\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.group-Union{Tuple{G}, Tuple{AbstractVector{G}, Vector{Int64}}} where G<:Graph","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.group","text":"function group(gv::Vector{Graph}, indices::Vector{Int})\n\nGroup the graphs in gv by the external operators at the indices indices. Return a dictionary of Vector{OperatorProduct} to GraphVector.\n\nExample\n\njulia> p1 = propagator([ùëì‚Å∫(1), ùëì‚Åª(2)]);\n\njulia> p2 = propagator([ùëì‚Å∫(1), ùëì‚Åª(3)]);\n\njulia> p3 = propagator([ùëì‚Å∫(2), ùëì‚Åª(3)]);\n\njulia> gv = [p1, p2, p3];\n\njulia> ComputationalGraphs.group(gv, [1, 2])\nDict{Vector{OperatorProduct}, Vector{Graph{Float64, Float64}}} with 3 entries:\n  [f‚Å∫(1), f‚Åª(3)] => [2:f‚Å∫(1)|f‚Åª(3)=0.0]\n  [f‚Å∫(1), f‚Åª(2)] => [1:f‚Å∫(1)|f‚Åª(2)=0.0]\n  [f‚Å∫(2), f‚Åª(3)] => [3:f‚Å∫(2)|f‚Åª(3)=0.0]\n\njulia> ComputationalGraphs.group(gv, [1, ])\nDict{Vector{OperatorProduct}, Vector{Graph{Float64, Float64}}} with 2 entries:\n  [f‚Å∫(2)] => [3:f‚Å∫(2)|f‚Åª(3)=0.0]\n  [f‚Å∫(1)] => [1:f‚Å∫(1)|f‚Åª(2)=0.0, 2:f‚Å∫(1)|f‚Åª(3)=0.0]\n\njulia> ComputationalGraphs.group(gv, [2, ])\nDict{Vector{OperatorProduct}, Vector{Graph{Float64, Float64}}} with 2 entries:\n  [f‚Åª(3)] => [2:f‚Å∫(1)|f‚Åª(3)=0.0, 3:f‚Å∫(2)|f‚Åª(3)=0.0]\n  [f‚Åª(2)] => [1:f‚Å∫(1)|f‚Åª(2)=0.0]\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.haschildren-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.haschildren","text":"function haschildren(g::Graph)\n\nReturns whether the graph has any children (subgraphs).\n\nArguments:\n\ng::Graph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.inplace_prod!-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.inplace_prod!","text":"function inplace_prod!(g::Graph)\n\nConverts a graph g representing a unary Prod chain to in-place form by merging its subgraph factors at\nroot level and pruning the resultant unary product operation(s), e.g., 2*(3*(5*g)) ‚Ü¶ 30*(*(*g)) ‚Ü¶ 30*g.\nDoes nothing unless g has the following structure: ùìû --- ‚ìç --- ‚ãØ --- ‚ìç ‚ãØ (!),\nwhere the stop-case (!) represents a leaf, an operator ùìû' != ‚ìç, or a non-unary ‚ìç node.\n\nArguments:\n\ng::Graph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.inplace_prod-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.inplace_prod","text":"function inplace_prod(g::Graph)\n\nReturns a copy of a graph g representing a unary Prod chain converted to in-place form by merging its subgraph \nfactors at root level and pruning the resultant unary product operation(s), e.g., 2*(3*(5*g)) ‚Ü¶ 30*(*(*g)) ‚Ü¶ 30*g.\nDoes nothing unless g has the following structure: ùìû --- ‚ìç --- ‚ãØ --- ‚ìç ‚ãØ (!),\nwhere the stop-case (!) represents a leaf, an operator ùìû' != ‚ìç, or a non-unary ‚ìç node.\n\nArguments:\n\ng::Graph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.interaction-Tuple{OperatorProduct}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.interaction","text":"function interaction(ops::OperatorProduct; name=\"\", reorder::Union{Function,Nothing}=nothing,\n    factor=one(_dtype.factor), weight=zero(_dtype.weight), operator=Sum())\nCreate a Interaction-type Graph from given OperatorProduct `ops`, including several quantum operators for a vertex.\nOne can call a reorder function for the operators ordering.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.is_external-Tuple{Graph, Int64}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.is_external","text":"function is_external(g::Graph, i::Int) \n\nCheck if `i::Int` in the external indices of Graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.is_internal-Tuple{Graph, Int64}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.is_internal","text":"function is_internal(g::Graph, i::Int) \n\nCheck if `i::Int` in the internal indices of Graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.isapprox_one-Tuple{Any}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.isapprox_one","text":"function isapprox_one(x)\n\nReturns true if x ‚âà one(x).\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.isbranch-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.isbranch","text":"function isbranch(g::Graph)\n\nReturns whether the graph g is a branch-type (depth-1 and one-child) graph.\n\nArguments:\n\ng::Graph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.ischain-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.ischain","text":"function ischain(g::Graph)\n\nReturns whether the graph g is a chain-type graph.\n\nArguments:\n\ng::Graph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.isequiv-Tuple{Graph, Graph, Vararg{Any}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.isequiv","text":"function isequiv(a::Graph, b::Graph, args...)\n\nDetermine whether `a` is equivalent to `b` without considering fields in `args`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.isfactorless-Tuple{Any}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.isfactorless","text":"function isfactorless(g)\n\nReturns whether the graph g is factorless, i.e., has unity factor and, if applicable,\nsubgraph factor(s). Note that this function does not recurse through subgraphs of g, so \nthat one may have, e.g., `isfactorless(g) == true` but `isfactorless(eldest(g)) == false`.\n\nArguments:\n\ng::Graph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.isleaf-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.isleaf","text":"function isleaf(g::Graph)\n\nReturns whether the graph g is a leaf (terminating tree node).\n\nArguments:\n\ng::Graph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.linear_combination-Union{Tuple{C}, Tuple{W}, Tuple{F}, Tuple{Array{Graph{F, W}, 1}, Vector{C}}} where {F, W, C}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.linear_combination","text":"function linear_combination(graphs::Vector{Graph{F,W}}, constants::Vector{C}) where {F,W,C}\n\nGiven a vector ùê† of graphs each with the same type and external/internal\nvertices and an equally-sized vector ùêú of constants, returns a new\ngraph representing the linear combination (ùêú ‚ãÖ ùê†).\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.linear_combination-Union{Tuple{C}, Tuple{W}, Tuple{F}, Tuple{Graph{F, W}, Graph{F, W}, C, C}} where {F, W, C}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.linear_combination","text":"function linear_combination(g1::Graph{F,W}, g2::Graph{F,W}, c1::C, c2::C) where {F,W,C}\n\nReturns a graph representing the linear combination `c1*g1 + c2*g2`.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_prefactors-Union{Tuple{Graph{F, W}}, Tuple{W}, Tuple{F}} where {F, W}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_prefactors","text":"function merge_prefactors(g::Graph)\n\nReturns a copy of graph g with multiplicative prefactors factorized,\ne.g., 3*g1 + 5*g2 + 7*g1 + 9*g2 ‚Ü¶ 10*g1 + 14*g2. Does nothing if \ngraph g does not represent a Sum operation.\n\nArguments:\n\ng::Graph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_prodchain_subfactors!-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_prodchain_subfactors!","text":"function merge_prodchain_subfactors!(g::Graph)\n\nSimplifies the subgraph factors of a graph g representing a unary Prod\nchain by merging them at root level, e.g., 2*(3*(5*g)) ‚Ü¶ 30*(*(*g)). \nDoes nothing unless g has the following structure: ùìû --- ‚ìç --- ‚ãØ --- ‚ìç ‚ãØ (!),\nwhere the stop-case (!) represents a leaf, an operator ùìû' != ‚ìç, or a non-unary ‚ìç node.\n\nArguments:\n\ng::Graph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.merge_prodchain_subfactors-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.merge_prodchain_subfactors","text":"function merge_prodchain_subfactors(g::Graph)\n\nReturns a copy of a graph g representing a unary Prod chain with subgraph factors\nsimplified by merging them at the root level, e.g., 2*(3*(5*g)) ‚Ü¶ 30*(*(*g)). \nDoes nothing unless g has the following structure: ùìû --- ‚ìç --- ‚ãØ --- ‚ìç ‚ãØ (!),\nwhere the stop-case (!) represents a leaf, an operator ùìû' != ‚ìç, or a non-unary ‚ìç node.\n\nArguments:\n\ng::Graph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.onechild-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.onechild","text":"function onechild(g::Graph)\n\nReturns whether the graph g has only one child (subgraph).\n\nArguments:\n\ng::Graph: graph to be analyzed\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.plot_tree-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.plot_tree","text":"function plot_tree(diag::Graph; verbose = 0, maxdepth = 6)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag        : the Graph struct to visualize\nverbose=0   : the amount of information to show\nmaxdepth=6  : deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.propagator-Tuple{Union{OperatorProduct, Vector{QuantumOperator}}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.propagator","text":"function propagator(ops::Union{OperatorProduct,Vector{QuantumOperator}};\n    name=\"\", factor=one(_dtype.factor), weight=zero(_dtype.weight), operator=Sum())\n\nCreate a Propagator-type Graph from given OperatorProduct or Vector{QuantumOperator} `ops`, including two quantum operators.\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.prune_trivial_unary-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.prune_trivial_unary","text":"function prune_trivial_unary(g::Graph)\n\nReturns a simplified copy of g if it represents a trivial unary chain.\nOtherwise, returns the original graph. For example, +(+(+g)) ‚Ü¶ g.\nDoes nothing unless g has the following structure: ‚ìç --- ‚ãØ --- ‚ìç ‚ãØ (!),\nwhere the stop-case (!) represents a leaf, an operator ùìû' != ‚ìç, or a non-unary ‚ìç node.\n\nArguments:\n\ng::Graph: graph to be modified\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.relabel!-Tuple{Graph, Dict{Int64, Int64}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.relabel!","text":"function relabel!(g::Graph, map::Dict{Int,Int})\n\nRelabels the quantum operators in g and its subgraphs according to `map`.\nFor example, `map = {1=>2, 3=>2}`` will find all quantum operators with labels 1 and 3, and then map them to 2.\n\nArguments:\n\ng::Graph: graph to be modified\nmap: mapping from old labels to the new ones\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.relabel-Tuple{Graph, Dict{Int64, Int64}}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.relabel","text":"function relabel(g::Graph, map::Dict{Int,Int})\n\nReturns a copy of g with quantum operators in g and its subgraphs relabeled according to `map`.\nFor example, `map = {1=>2, 3=>2}` will find all quantum operators with labels 1 and 3, and then map them to 2.\n\nArguments:\n\ng::Graph: graph to be modified\nmap: mapping from old labels to the new ones\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.replace_subgraph!-Tuple{Graph, Graph, Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.replace_subgraph!","text":"function replace_subgraph!(g::Graph, w::Graph, m::graph)\n\nModifies g by replacing the subgraph w with a new graph m.\nSubgraphs w and m should have the same type, orders, and external vertices.\n\nArguments:\n\ng::Graph: graph to be modified\nw::Graph: subgraph to replace\nm::Graph: new subgraph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.replace_subgraph-Tuple{Graph, Graph, Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.replace_subgraph","text":"function replace_subgraph(g::Graph, w::Graph, m::graph)\n\nCreates a modified copy of g by replacing the subgraph w with a new graph m.\nSubgraphs w and m should have the same type, orders, and external vertices.\n\nArguments:\n\ng::Graph: graph to be modified\nw::Graph: subgraph to replace\nm::Graph: new subgraph\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.standardize_labels!-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.standardize_labels!","text":"function standardize_labels!(g::Graph)\n\nFinds all labels involved in g and its subgraphs and \nmodifies g by relabeling in standardized order, e.g.,\n(1, 4, 5, 7, ...) ‚Ü¶ (1, 2, 3, 4, ....)\n\nArguments:\n\ng::Graph: graph to be relabeled\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.standardize_labels-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.standardize_labels","text":"function standardize_labels!(g::Graph)\n\nFinds all labels involved in g and its subgraphs and returns \na copy of g relabeled in a standardized order, e.g.,\n(1, 4, 5, 7, ...) ‚Ü¶ (1, 2, 3, 4, ....)\n\nArguments:\n\ng::Graph: graph to be relabeled\n\n\n\n\n\n","category":"method"},{"location":"lib/computgraph/#FeynmanDiagram.ComputationalGraphs.vertices-Tuple{Graph}","page":"Computational graph for general feynman diagrams","title":"FeynmanDiagram.ComputationalGraphs.vertices","text":"function vertices(g::Graph)\n\nReturn all vertices (::Vector{OperatorProduct}) of Graph `g`.\n\n\n\n\n\n","category":"method"},{"location":"manual/interaction/#Interaction/Scattering-Amplitude-Convention","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"In general, the interaction (or scattering amplitude) between two spin-12 particles only has two independent spin components. Here we briefly review some of the common conventions of the spin components in literature, and show how to map between different conventions.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"We assume a particle from the left collides with a particle from the right. Due to the interaction between the two particles, one of them scatters to the left, and the other to the right. ","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"We will use the index alphabetagammadelta to label the left incoming, the left outgoing, the right incoming and the right outgoing particles. We assume four legs associate with four momentum-frequency vectors k_1 k_2 k_3 k_4.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"There are two possible scatterings: a direct scattering where the two particles don't permutate after the collision, and an exchange scattering where the two particles permutate. Therefore, the total scattering amplitude has two contributions,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v_alphabetagammadelta(1234) = v^d_alphabetagammadelta(1234)+v^e_alphabetagammadelta(1234)","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where the exchange contribution is different from the direct counterpart up to an exchange of two outgoing legs and an overall particle statistic sign xi =pm 1,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xi v^d_alphadeltagammabeta(1432)","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where we have abbreviated the momentum-frequency vectors as indices.","category":"page"},{"location":"manual/interaction/#.-Spin-symmetric-and-asymmetric-convention:","page":"Interaction/Scattering-Amplitude Convention","title":"1. Spin symmetric and asymmetric convention:","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"A interaction is split into a term that is independent of the spin (e.g., Coulomb interaction between electrons) and a term with spin dependence (e.g., ferromagnetic/antiferromagnetic interaction). This convention is commonly used in textbooks of Fermi liquid theory.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_alphabetagammadelta(1234) equiv v^s_1234delta_alphabetadelta_gammadelta + v^a_1234 vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"where the superscript d means the scattering is direct.","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"If two particles permute after the collision, then one needs to exchange beta leftrightarrow gamma and other internal variables,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xi v^s_1432delta_alphadeltadelta_gammabeta + xi v^a_1432 vecsigma_alphadeltacdot vecsigma_gammabeta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_alphabetagammadelta(1234) = xifracv^s_1432+3v^a_14322delta_alphabetadelta_gammadelta + xi fracv^s_1432-v^a_14322 vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"To derive the above equations, we use the identity vecsigma_alphabetacdot vecsigma_gammadelta=2 delta_alpha delta delta_beta gamma-delta_alpha beta delta_gamma delta, which gives the following equations,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"delta_alphadeltadelta_gammabeta=frac12delta_alphabetadelta_gammadelta+frac12vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"and,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"vecsigma_alphadeltacdot vecsigma_gammabeta=frac32delta_alphabetadelta_gammadelta-frac12vecsigma_alphabetacdot vecsigma_gammadelta","category":"page"},{"location":"manual/interaction/#.-Spin-\\uparrow\\uparrow-and-\\uparrow\\downarrow-convention:","page":"Interaction/Scattering-Amplitude Convention","title":"2. Spin uparrowuparrow and uparrowdownarrow convention:","text":"","category":"section"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"An alternative parameterization of the interaction matrix is by specifiying the spin components v_uparrowuparrow equiv v_uparrowuparrowuparrowuparrow and v_uparrowdownarrow equiv v_uparrowuparrowdownarrowdownarrow. They can be derived from v_s and v_a by the simple relation,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_uparrowuparrow(1234) = v^s_1234+v^a_1234","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^d_uparrowdownarrow(1234) = v^s_1234-v^a_1234","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"If two particles permute after the collision, the exchange interaction v^e,","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_uparrowuparrow(1234) = xifracv^s_1432+3v^a_14322+xifracv^s_1432-v^s_14322 = xi v^s_1432+ xi v^a_1432","category":"page"},{"location":"manual/interaction/","page":"Interaction/Scattering-Amplitude Convention","title":"Interaction/Scattering-Amplitude Convention","text":"v^e_uparrowdownarrow(1234) = xifracv^s_1432+3v^a_14322-xifracv^s_1432-v^s_14322 = 2 xi v^a_1432","category":"page"},{"location":"manual/feynman_rule/#Feynman-Rules","page":"Feynman Rules","title":"Feynman Rules","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"In general, we follow the convention in the textbook \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95,","category":"page"},{"location":"manual/feynman_rule/#Fourier-Transform","page":"Feynman Rules","title":"Fourier Transform","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"G(tau) = frac1beta sum_n G(iomega_n) texte^-iomega_n tau","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"G(iomega_n) = int_0^beta G(tau) texte^iomega_n tau dtau","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where the Matsubara-frequency omega_n=2pi nbeta for boson and omega_n = 2pi (n+1)beta for fermion.","category":"page"},{"location":"manual/feynman_rule/#Action-and-Partition-Sum","page":"Feynman Rules","title":"Action and Partition Sum","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The partition sum associates with a generic action,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Z = int mathcalDbarpsimathcalDpsi expleft(-Sright)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where the action takes a generic form,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"S = barpsi_1left(fracpartialpartial tau +epsilon_k right)psi_1 + V_1234barpsi_1barpsi_2psi_3psi_4","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where barpsi and psi are Grassman fields.","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"In the Matsubara-frequency domain, the action is,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"S = barpsi_1left(-iomega_n +epsilon_k right)psi_1 + V_1234barpsi_1barpsi_2psi_3psi_4","category":"page"},{"location":"manual/feynman_rule/#Bare-Propagator","page":"Feynman Rules","title":"Bare Propagator","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Imaginary time","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"g(tau k) = leftmathcalT psi(k tau) barpsi(k 0) right_0= frace^-epsilon_k tau1+e^-epsilon_k betatheta(tau)+xi frace^-epsilon_k (beta+tau)1+e^-epsilon_k betatheta(-tau)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where xi is +1 for boson and -1 for fermion.","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Matusbara frequency","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"g(iomega_n k) = -frac1iomega_n-epsilon_k","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Then the action takes a simple form,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"S = barpsi_1g_12^-1psi_2 + V_1234barpsi_1barpsi_2psi_3psi_4","category":"page"},{"location":"manual/feynman_rule/#Dressed-Propagator-and-Self-energy","page":"Feynman Rules","title":"Dressed Propagator and Self-energy","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The dressed propagator is given by,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"G(tau k) = leftmathcalT psi(k tau) barpsi(k 0) right","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"and we define the self-energy Sigma as the one-particle irreducible vertex function,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"G^-1 = g^-1 + Sigma","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"so that","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"G = g - gSigma g + gSigma g Sigma g - ","category":"page"},{"location":"manual/feynman_rule/#Perturbative-Expansion-of-the-Green's-Function","page":"Feynman Rules","title":"Perturbative Expansion of the Green's Function","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Sign rule for the Wick contractions.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Diagrammatic expansion of the Green's function.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The sign of a Green's function diagram is given by (-1)^n_v xi^n_F, where","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"n_v is the number of interactions.\nn_F is the number of the fermionic loops.","category":"page"},{"location":"manual/feynman_rule/#Feynman-Rules-for-the-Self-energy","page":"Feynman Rules","title":"Feynman Rules for the Self-energy","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"From the Green's function diagrams, one can derive the negative self-energy diagram,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Diagrammatic expansion of the self-energy.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"beginaligned\n-Sigma =  (-1) xi V_34 g_44+(-1) V_34 g_34 \n+(-1)^2 xi V_34 V_56 g_46 g_64 g_43+(-1)^2 V_34 V_56 g_35 g_54 g_42+cdots\nendaligned","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The sign of a negative self-energy -Sigma diagram is given by (-1)^n_v xi^n_F, where","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"n_v is the number of interactions.\nn_F is the number of the fermionic loops.","category":"page"},{"location":"manual/feynman_rule/#Feynman-Rules-for-the-3-point-Vertex-Function","page":"Feynman Rules","title":"Feynman Rules for the 3-point Vertex Function","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The self-energy is related to the 3-point vertex function through an equation,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"-left(Sigma_3 x -Sigma^Hartree_3 xright) = G_3y cdot left(-V_3 4right) cdot Gamma^3_4yx","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where the indices x y could be different from diagrams to diagrams, and Gamma_3 is the inproper three-vertex function. Eliminate the additional sign, one derives,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Sigma_3 x -Sigma^Hartree_3 x = G_3y cdot V_3 4 cdot Gamma^3_4yx","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Diagrammatic expansion of the 3-point vertex function.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The diagram weights are given by,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"beginaligned\nGamma^(3)=  1 + (-1) xi V_56 g_46 g_64 + (-1) V_56 g_54 g_46\n+(-1)^2 xi^2 V_56 V_78 g_46 g_64 g_58 g_85+(-1)^2xi V_56 V_78 g_74 g_46+cdots\nendaligned","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The sign of Gamma^(3) diagram is given by (-1)^n_v xi^n_F.","category":"page"},{"location":"manual/feynman_rule/#Feynman-Rules-for-the-4-point-Vertex-Function","page":"Feynman Rules","title":"Feynman Rules for the 4-point Vertex Function","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The 4-point vertex function is related to the 3-point vertex function through an equation,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"Gamma^(3)_4yx = xi cdot G_4s cdot G_t 4 cdot Gamma^(4)_s t y x","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where the indices x y s t could be different from diagrams to diagrams.","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Diagrammatic expansion of the 4-point vertex function.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The diagram weights are given by,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"beginaligned\nGamma^(4)=  (-1) V_56^textdirect + (-1)xi V_56^exchange\n+(-1)^2 xi V_56 V_78 g_58 g_85+(-1)^2 V_56 V_78+cdots\nendaligned","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"where we used the identity xi^2 = 1.","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The sign of Gamma^(4) diagram is given by (-1)^n_v xi^n_F multiplied with a sign from the permutation of the external legs.","category":"page"},{"location":"manual/feynman_rule/#Feynman-Rules-for-the-Susceptibility","page":"Feynman Rules","title":"Feynman Rules for the Susceptibility","text":"","category":"section"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"The susceptibility can be derived from Gamma^(4).","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"chi_12 equiv leftmathcalT n_1 n_2right_textconnected = xi G_12 G_2 1 + xi G_1s G_t 1 Gamma^(4)_s t y x G_2y G_x 2","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"(Image: Diagrammatic expansion of the susceptibility.)","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"We define the polarization P as the one-interaction irreducible (or proper) vertex function,","category":"page"},{"location":"manual/feynman_rule/","page":"Feynman Rules","title":"Feynman Rules","text":"chi^-1 = P^-1 + V","category":"page"},{"location":"manual/hubbard_atom/#Hubbard-Atom-as-a-Test-Case","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"One may use the Hubbard atom model to benchmark the Feynman diagrams generated by FeynmanDiagram.jl. In this note, we derive the vertex functions and their power expansion in interaction. The test is implemented in the test folder.","category":"page"},{"location":"manual/hubbard_atom/#Hamiltonian","page":"Hubbard Atom as a Test Case","title":"1 Hamiltonian","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"hatH=U n_uparrow n_downarrow-mu (n_uparrow+n_downarrow)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"where U is the on-site interaction, mu is the chemical potential.","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"The eigenstates are,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"left 0 right\n: E_0=0.\nleft uparrow right\nand left downarrow right : E_1=-mu.\nleft uparrow downarrow right\n: E_2=U-2mu.","category":"page"},{"location":"manual/hubbard_atom/#Partition-sum","page":"Hubbard Atom as a Test Case","title":"2 Partition sum","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Z=1+2e^mubeta+e^-beta(U-2mu)","category":"page"},{"location":"manual/hubbard_atom/#Two-point-Green's-function","page":"Hubbard Atom as a Test Case","title":"3 Two-point Green's function","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"For the imaginary-time tau0,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(tau)=lefttextT c_uparrow(tau) c^+_uparrow(0) right=frac1Zsum_n left nrighte^-(beta-tau)Hc_uparrow e^-tau H c^+_uparrow left n right","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Only the states left 0 right and left downarrow right contribute,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(tau)=frace^mu tau+e^mu betae^-(U-mu)tauZ","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"For example, at half filling mu=U2, there is one particle and,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(tau)=frace^-Utau2+e^-U(beta-tau)22(1+e^-Ubeta2)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Transform to the Matsubara frequency,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(iomega_n) = int_0^beta G(tau)e^iomega_ntau dtau","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"G(iomega_n)=-frac1Zleft(frac1+e^mu betaiomega_n+mu+e^mubetafrac1+e^-(U-mu)betaiomega_n-(U-mu)right)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"By setting U=0, one can show that the above dressed Green's function reduce to the bare one,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"g(iomega_n) = -frac1iomega_n+mu","category":"page"},{"location":"manual/hubbard_atom/#Self-energy","page":"Hubbard Atom as a Test Case","title":"4 Self-energy","text":"","category":"section"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"The self-energy is defined as G^-1(iomega_n)=g^-1(iomega_n)-Sigma(iomega_n), so that","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Sigma(iomega_n) = fracU e^beta  mu  (mu +i w) left(e^beta  mu +e^beta  Uright)e^beta  U (-mu +U-i w)+e^beta  (mu +U) (-2 mu +U-2 i w)-e^2 beta  mu  (mu +i w)","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"For benchmark purpose, here we also provide the power expansion of the self-energy at the low-energy limit omega_0 = pi beta with mu=0,","category":"page"},{"location":"manual/hubbard_atom/","page":"Hubbard Atom as a Test Case","title":"Hubbard Atom as a Test Case","text":"Sigma(iomega_0) = -fracU2+frac(pi +2 i) beta  U^28 pi -fracleft(pi ^2-4right) beta ^2 U^332 pi ^2-fracleft(24 i-12 pi +6 i pi ^2+pi ^3right) beta ^3 U^4384 pi ^3+fracleft(-48-48 i pi -24 pi ^2+12 i pi ^3+5 pi ^4right) beta ^4 U^51536 pi ^4+Oleft(U^6right)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FeynmanDiagram","category":"page"},{"location":"#FeynmanDiagram","page":"Home","title":"FeynmanDiagram","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FeynmanDiagram.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FeynmanDiagram]","category":"page"},{"location":"#FeynmanDiagram.innerTauNum-NTuple{4, Any}","page":"Home","title":"FeynmanDiagram.innerTauNum","text":"function innerTauNum(type, innerLoopNum, interactionTauNum)\n\ninternal imaginary-time degrees of freedom for a given diagram type and internal loop number.\nFor the vertex functions (self-energy, polarization, vertex3, and vertex4), innerTauNum is equivalent to tauNum.\nFor the Green function, tauNum = innerTauNum + external tauNum\n\n\n\n\n\n","category":"method"},{"location":"#FeynmanDiagram.innerTauNum-Tuple{FeynmanDiagram.DiagramType, Any, Any}","page":"Home","title":"FeynmanDiagram.innerTauNum","text":"function innerTauNum(type::DiagramType, innerLoopNum, interactionTauNum)\n\ninternal imaginary-time degrees of freedom for a given diagram type and internal loop number.\nFor the vertex functions (self-energy, polarization, vertex3, and vertex4), innerTauNum is equivalent to tauNum.\nFor the Green function, tauNum = innerTauNum + external tauNum\n\n\n\n\n\n","category":"method"},{"location":"#Parameters.reconstruct-Union{Tuple{W}, Tuple{Type{DiagPara{W}}, DiagPara{W}, Any}} where W","page":"Home","title":"Parameters.reconstruct","text":"Parameters.reconstruct(p::DiagPara; kws...)\n\nType-stable version of the Parameters.reconstruct\n\n\n\n\n\n","category":"method"},{"location":"#Parameters.reconstruct-Union{Tuple{W}, Tuple{Type{DiagramPara{W}}, DiagramPara{W}, Any}} where W","page":"Home","title":"Parameters.reconstruct","text":"Parameters.reconstruct(p::DiagramPara; kws...)\n\nType-stable version of the Parameters.reconstruct\n\n\n\n\n\n","category":"method"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/operator.md\",\n    \"lib/computgraph.md\",\n    \"lib/frontend.md\",\n    \"lib/GV.md\",\n    \"lib/parquet.md\",\n    \"lib/diagtree.md\",\n    \"lib/exprtree.md\",\n]\nDepth = 2","category":"page"},{"location":"manual/counterterms/#Evaluation-of-counterterms","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"","category":"section"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"For illustrative simplicity, let us consider the renormalization of the chemical potential and Yukawa effective mass in the uniform electron gas (UEG). Following the Negele & Orland conventions, the non-interacting Green's function g is given by","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" g(mathbfk iomega_n) = -frac1iomega_n-epsilon_mathbfk + mu","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where G is the bold Green's function, omega_n = 2pi (n+1)beta is a fermionic Matsubara frequency, and mu is the exact chemical potential derived from the interacting density n. The 1PI self-energy Sigma is then defined through the following Dyson equation:","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" G^-1 = g^-1 + Sigma implies G = g - gSigma g + gSigma g Sigma g - ","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Following the variational diagrammatic Monte-Carlo (VDMC) approach, we rewrite the bare Green's function g in terms of a renormalized propagator g_R, writing","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" g(mathbfk iomega_n) = -frac1iomega_n-epsilon_mathbfk + mu_R + deltamu","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where, motivated by Luttinger's theorem, the renormalized chemical potential mu_R = mu - deltamu equiv epsilon_F = k^2_F  2 m is chosen so as to preserve the non-interacting Fermi surface, whereas lambda is taken as a fixed, non-zero constant.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Similarly, the Coulomb interaction is re-written as","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" V(q) = frace^2epsilon_0 q^2 = frace^2epsilon_0 frac1q^2 + lambda + deltalambda","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"We then work perturbatively in terms of the following renormalized Green's function and interaction,","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n g_R(k iomega_n) equiv -frac1iomega_n-epsilon_k + mu_R = g(k iomega_n) Big_deltamu = 02ex\n V_lambda(q) equiv frace^2epsilon_0 frac1q^2 + lambda = V(q) Big_deltalambda = 0\nendaligned","category":"page"},{"location":"manual/counterterms/#New-approach-to-counterterm-evaluation","page":"Evaluation of counterterms","title":"New approach to counterterm evaluation","text":"","category":"section"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"In the NEFT codebase, the counterterms are generated by directly differentiating diagrams in the perturbative series for a given observable, which allows for a flexible and generic reformulation of the VDMC algorithm. This is made possible by representing all diagrams by differentiable expression trees. In contrast, in the original VDMC approach one first Taylor expands all propagators gg_R and VV_lambda entering a given observable by hand and collects terms in orders of xi manually prior to integration.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"The mathcalO(xi^N) counterterms in RPT with n and m chemical potential / interaction derivatives are given by","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" (deltamu)^n (deltalambda)^m times frac1n mpartial^n_mu partial^m_lambda D_N - n - m","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where D is the sum of all Feynman diagrams at the appropriate loop order N - n - m. The renormalization is performed in post-processing by multiplying with the Taylor series for (deltamu)^n (deltalambda)^m in xi and collecting terms propto xi^N. The chemical potential shift delta mu_n is derived from a separate MC simulation of Sigma^lambda_R_F(k_F ik_0).","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"To demonstrate that the two approaches outlined above are equivalent, it is sufficient to consider separately the cases of V and g raised to an arbitrary power in the Matsubara representation; we will omit the coordinates for brevity.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"First, consider the chemical potential counterterms. Let deltamu equiv mu_0 - mu_R. Taylor expanding gg_R about deltamu = 0, we have","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" g = fracg_R1 - g_Rdeltamu = g_Rsum^infty_n=0 (g_Rdeltamu)^n = sum^infty_n=0 frac(deltamu)^nn partial^n_mu g_R","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"since","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" g^n+1_R = frac1n partial^n_mu g_R","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Then,","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n g^m  = left(sum^infty_n=0 frac(deltamu)^nn partial^n_mu g_Rright)^m = g^m_Rleft(1 - g_Rdeltamuright)^-m = g^m_R sum^infty_n=0 binomm+n-1n (g_Rdeltamu)^n\n      = sum^infty_n=0 (deltamu)^n frac(m+n-1)n (m-1) g^m+n_R = sum^infty_n=0 frac(deltamu)^nn (m-1) partial^m+n-1_mu g_R = sum^infty_n=0 frac(deltamu)^nn partial^n_mu g^m_R\nendaligned","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where in the last step, we replaced","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n frac1(m-1) partial^m-1_mu g_R = g^m_R\nendaligned","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Thus, the series for g^m may be represented either by expanding each gg_R by hand and collecting terms, or by a direct Taylor expansion of g^m about deltamu = 0.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"It remains to show that these two strategies are also equivalent for the expansion of V^m. Let deltalambda equiv lambda_0 - lambda_R = -lambda_R and Taylor expand VV_lambda about deltalambda = 0‚Äîwe obtain","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"\n  V = fracV_ lambda1 - fraclambdaq^2 + lambda = V_lambda sum_n=0^infty left(fraclambdaq^2 + lambdaright)^n = V_lambda sum_n=0^infty left(V_lambda deltalambdaright)^n = sum^infty_n=0 frac(-lambda)^nn partial^n_lambda V_lambda\n","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" V = fracV_ lambda1 - delta_lambda = V_lambda sum_n=0^infty delta^n_lambda = sum^infty_n=0 frac(deltalambda)^nn partial^n_lambda V_lambda","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" delta_lambda equiv fraclambdaq^2 + lambda","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"since","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n frac(deltalambda)^nn partial^n_lambda V_lambda = 8pifrac(-lambda)^nn partial^n_lambda left(frac1q^2 + lambdaright) = frac8pilambda^n(q^2 + lambda)^n+1 = V_lambda delta^n_lambda\nendaligned","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"We also have that","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n frac(deltalambda)^nn partial^n_lambda V^m_lambda = left(fraclambda8piright)^n fracm^(n)n V^m+n_lambda = binomm + n - 1n V^m_lambda delta^n_lambda\nendaligned","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"where m^(n) = prod_i=0^n-1 (m + i) is a rising factorial and","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":" binomm + n - 1n = frac(m + n - 1)n (m-1) = fracm^(n)n","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Thus,","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"beginaligned\n V^m  = left(sum^infty_n=0 frac(deltalambda)^nn partial^n_lambda V_lambdaright)^m = V^m_lambda left(1 - delta_lambdaright)^-m = sum^infty_n=0 binomm+n-1n V^m_lambda delta^n_lambda = sum^infty_n=0 frac(deltalambda)^nn partial^n_lambda V^m_lambda\nendaligned","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"Since the order of differentiation w.r.t. mu and lambda does not matter, it follows that a general diagram mathcalDg V sim g^n V^m may be represented either by pre-expanding gg_mu and VV_lambda and collecting terms, or by directly evaluating terms in the Taylor series for mathcalDg_mu V_lambda; this codebase uses the latter approach.","category":"page"},{"location":"manual/counterterms/#Evaluation-of-interaction-counterterms","page":"Evaluation of counterterms","title":"Evaluation of interaction counterterms","text":"","category":"section"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"An example of the interaction counterterm evaluation for a diagram with n_lambda = 3 and m interaction lines. Since the Julia implementation evaluates the interaction counterterms of a given diagram as frac(-lambda)^nnpartial^n_lambda V^m_lambda, we pick up an extra factor of l on each lth-order derivative in the chain rule.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"(Image: An example of the representation of interaction counterterm diagrams via differentiation.)","category":"page"},{"location":"manual/counterterms/#Benchmark-of-counterterms-in-the-UEG","page":"Evaluation of counterterms","title":"Benchmark of counterterms in the UEG","text":"","category":"section"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"As a concrete example, we have evaluated the individual diagrams and associated counterterms entering the RPT series for the total density ng_mu V_lambda in units of the non-interacting density n_0. The diagrams/counterterms are denoted by partitions mathcalP equiv (n_textloop n_mu n_lambda) indicating the total loop order and number of mu and lambda derivatives.","category":"page"},{"location":"manual/counterterms/#D-UEG","page":"Evaluation of counterterms","title":"3D UEG","text":"","category":"section"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"For this benchmark, we take r_s = 1, beta = 40 epsilon_F, and lambda = 06. All partitions contributing up to 4th order are included, as well as some selected partitions at 5th and 6th order.","category":"page"},{"location":"manual/counterterms/","page":"Evaluation of counterterms","title":"Evaluation of counterterms","text":"(n_textloop n_lambda n_mu) n  n_0\n(1, 0, 1) 0.40814(16)\n(1, 0, 2) 0.02778(21)\n(1, 0, 3) -0.00096(60)\n(2, 0, 0) 0.28853(12)\n(2, 1, 0) 0.07225(3)\n(2, 2, 0) 0.02965(2)\n(2, 0, 1) 0.09774(30)\n(2, 1, 1) 0.01594(10)\n(2, 0, 2) 0.00240(130)\n(3, 0, 0) 0.10027(37)\n(3, 1, 0) 0.04251(21)\n(3, 0, 1) 0.02600(150)\n(4, 0, 0) 0.00320(130)\n(2, 1, 2) -0.00111(18)\n(2, 0, 3) -0.00430(150)\n(3, 2, 0) 0.02241(8)\n(3, 3, 0) 0.01429(7)","category":"page"}]
}
